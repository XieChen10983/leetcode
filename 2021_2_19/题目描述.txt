1. 给定一个非负整数n，生成杨辉三角的前n行
    解法：特殊情况，n = 0、1、2
         一般情况：从i=2开始迭代到n-1，每次迭代以上行为base，根据上一行生成新的行，之后更新base和新行即可。

2. 给定一个非负索引k，其中k小于等于33，返回杨辉三角的第k行
    解法：每一项都是一个组合数，不需要分别计算，可以通过上下组合数之间的关系C(n, m) = C(n, m-1) * (n - m + 1) / m;

3. 给定一个数组prices，它的第i个元素prices[i]表示一支给定股票第i天的价格。选择某一天买入和卖出，设计一个算法计算所能获取的最大利润。
    解法：循环遍历，每一次遍历只需判断是否为最低点，如果是就更新。如果不是，和当前最低点做差得到利润，和当前的最高利润比较，看是否是最高利润，如果是则更新

4. 给定一个数组，可以尽可能地完成多次交易，设计算法来计算所能获得的最大利润。
    n个区间，只需要判断区间内的涨跌，如果涨则相加，否则，不加。

5. 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
    解法：使用双指针，分别从左右两边进行判断。可以使用cctype头文件中的isalnum(char c)函数判断是否为字母或数字，使用tolower(char c)将字符变成小写之后再进行判断

6. 给定一个二叉树，找出其最小深度——根节点到最近节点的最短路径上的节点数量
    解法1：递归，最小深度=1+左右子树的最小深度的更小者。
    解法2：广度优先搜索——利用que进行层次遍历，当遍历到没有左右子树(即叶子)的时候可以返回。

7. 给你二叉树的根节点root和一个表示目标和的整数targetSum，判断该树中是否存在根节点到叶子节点的路径，路径节点上和等于该目标和
    解法：通过队列对树进行层次遍历。每次遍历的时候更新左右节点的目标和(等于左右节点原本加上此节点)，判断当前节点是否为叶子节点，如果是判断和是否等于目标和

8. 给定一个非空整数数组，除了某个元素只出现一次之外，其余每个元素均出现了两次。找出那个只出现了一次的元素。
    解法：可以使用异或操作。

9. 设计一个支持push、pop和top操作，并且能在常数时间内检索到最小元素的栈
    解法：使用栈来辅助，每次存入一个数时，同时存入其对应的最小值(通过和当前最小值比较获得最小值)。每次取出一个数时，更新最小值，注意已经取完时的情况。
        最小值的存入可以通过另外一个栈来存储，也可以和存入值组成pair同时存入。

10. 给定一个已经按照升序排列的整数数组numbers，请你从数组中找出两个数满足和等于目标数target。可以假设每个输入只对应唯一的答案，且不可以使用重复的元素。
    解法：使用左右指针法，和大右减，和小左加

11. 给定一个正整数，返回它在Excel表中对应的列名称：1->A, 2->B, ..., 26->Z, 27->AA
    解法：每次从余数开始算起，也就是从后向前看，减一取模26，看需要添加的是什么即可。例如28，余数为2，减一为1模26为1对应B，商为1，继续减一模26为0->A,因此为AB
        如果是56，减一模26 = 3， 对应D，商为2，减一模26为1，对应B，因此为BD。