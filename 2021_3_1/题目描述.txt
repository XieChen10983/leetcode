1. 编写一个高效算法来判断m*n矩阵中是否存在一个目标值，该矩阵具有如下特性：每行中的整数从左到右按照升序排列。每行的第一个整数大于前一行的最后一个整数。
    解法：二分查找

2. 给定一个包含红色、白色和蓝色一共n个元素的数组，原地对他们进行排序，其中红色白色和蓝色分别用0，1，2表示。
    解法：可以记录012的个数，再重新填入。还可以设置左右两个指针，交换0和2。

3. 一个机器人位于一个m*n的网格的左上角，机器人每次只能向下或者向右移动一步，请问机器人试图达到网格的右下角总共有多少条不同的路径？
    解法：动态规划的方法：f(i, j) = f(i-1, j) + f(i, j - 1);其中边界条件为从左上角走到上面边任意一点都只有1种走法，走到左边的边也只有一种走法

4. 一个机器人位于一个m*n的网格的左上角，机器人每次只能向下或者向右移动一步，如果网格中有障碍物不能通过，请问机器人试图达到网格的右下角总共有多少条不同的路径？
    解法：同3，只需要将障碍物处换成0即可

5. 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小.
    解法：同样是动态规划的方法，f(i, j) += min(f(i - 1, j), f(i, j - 1))

6. 给你一个链表的头节点head和一个特定值x，请你对链表进行分隔，使得所有小于x的节点都出现在大于或者等于x的节点之前。
    解法：只需维护两个链表small和large 即可small链表按顺序存储所有小于的节点，large链表按顺序存储所有大于等于的节点。遍历完原链表后，我们只要将
    small链表尾节点指向large链表的头节点即能完成对链表的分隔。

7. 翻转从位置m到n的链表，请用一趟扫描完成翻转