1. 给定两个整数，被除数和除数。将两数相除，要求不使用乘法、除法和mod运算符。返回商
    解法：a 通过除数的自相加——即倍增快速找到商的上限例如60/8的话，8->16->32->64发现64>60了，知道其最大为32
            同时倍数也倍增1->2->4，则商=60/8=(32+28)/8 = (32 + 16 + 12) / 8 = (32 + 16 + 8 + 4) / 8 = 4 + 2 + 1 = 7
            可以使用栈来存储倍数和自相加倍增的数
         b 同时需要考虑整型数的上下界。


2. 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。[1, 2, 3, 4] -> [2, 1, 4, 3]
    构造一个哑节点，在需要交换对的前面。当哑节点后面不为空且后面的后面不为空的时候，交换哑节点后面的对，并且更新哑节点（变为对的第二个节点）。
    当哑节点后面为空或者后面的后面为空的时候，直接结束迭代，不用交换。最后返回第一个哑节点的后面节点即可。


3. 给定两个以字符串形式表示的非负整数num1和num2，以字符串的形式返回两者的乘积。
    解法：创建一个size_1+size_2大小的向量arr，从后向前遍历num1和num2中的数，相乘并加到arr[i+j+1]中
        再从后向前处理arr中的值，取模10并进位。
        最后将arr的结果转换为字符串


4. 给定一个链表，判断链表中是否有环
    解法：a 使用哈希表，遍历保存并查询是否已经在哈希表中
         b 使用快慢指针，快指针一次走俩，慢指针一次走一

5. 给定一个二叉树，判断它是否是高度平衡的二叉树
    解法1：先递归地构造计算节点高度的函数，再暴力递归判断是否平衡（左右高度相差不超过1，且左右子树均平衡）
    解法2：从底向上判断节点，左右节点是否高度平衡，若平衡，返回高度；若不平衡，直接返回-1；在实现从下到上的判断的时候也是使用的递归，leftHeight = recur(root->height)