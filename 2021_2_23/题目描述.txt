1. 给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。
    解法：回溯：dfs(root):
                dfs(root->left)
                dfs(root->right)
                pop()


2. 给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。
    同样可以使用深度优先搜索。

3. 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
    解法：使用队列进行广度优先搜索

4. 给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
    解法：1. 可以在3的基础上判断是否从左到右顺序，如果不是，在添加之前reserve翻转。
         2. 每一层可以使用双端队列而不是vector来存储，如果是从左到右是push_back(),如果是从右到左则是push_front。最后添加层次的时候使用将deque转为vector即可

5. 给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。每个节点还有一个next指针，填充它的每个 next 指针，让这个指针指向其下一个右侧节点。
    如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
    解法1：利用队列进行层次遍历，在遍历的时候可以直接将左侧节点的next指向右侧节点。
    解法2：可以使用上一层建立好的节点帮助next的指向。